-- 2025 02 20

-- https://tproger.ru/translations/sql-window-functions

-- Оконные функции в SQL - что это и зачем они нужны


-- Разобраться в оконных функциях ORDER BY и PARTITION BY


-- Почему не GROUP BY и не JOIN

-- Оконные функции не уменьшают количество строк, а возврщают столько же значений, сколько получили на вход
-- Во-вторых, в отлияие от GORUP BY, OVER может обращать к другим строкам.
-- И в-третьих, они могут считать скользящие средние и кумулятивные суммы.


-- Окей, с GROUP BY разобрались, в но в SQL практически всегда можно пойти несколькими путями.
-- К примеру, может вонзикнуть желание использовать подзапросы или JOIN.
-- Конечно, JOIN по производительности предпочтительнее подзапросов,
-- а производительность конструкций JOIN и OVER окажется одинаковой.
-- Но OVER даёт больше свободы, чем жесткий JOIN.
-- Да и объем кода в итоге окажется гораздо меньше


-- Для начала

-- Оконные функции начинаются с оператора OVER и настраиваются с помощью трёх других операторов:
-- PARTITION BY, ORDER BY и ROWS.

-- Про ORDER BY, PARTITION BY и его вспомогательные операторы LAG, LEAD, RANK мы расскажем подробнее

-- Все примеры основаны на датасете олимпийских медалистов от Datacamp.
-- Таблица называется summer_medals и содержит результаты Олимпиад с 1896 по 2010:

-- ROW_NUMBER и ORDER BY

-- Как уже говорилось выше, оператор OVER создаёт оконную функцию.
-- Начнем с простой функции ROW_NUMBER, которая присваивает номер каждой выбранной записи:

SELECT
athlete,
event,
ROW_NUMBER() OVER() AS row_number
FROM Summer_Medals
ORDER BY row_numbers ASC;




