-- 2025 02 20

-- https://tproger.ru/translations/sql-window-functions

-- Оконные функции в SQL - что это и зачем они нужны


-- Разобраться в оконных функциях ORDER BY и PARTITION BY


-- Почему не GROUP BY и не JOIN

-- Оконные функции не уменьшают количество строк, а возврщают столько же значений, сколько получили на вход
-- Во-вторых, в отлияие от GORUP BY, OVER может обращать к другим строкам.
-- И в-третьих, они могут считать скользящие средние и кумулятивные суммы.


-- Окей, с GROUP BY разобрались, в но в SQL практически всегда можно пойти несколькими путями.
-- К примеру, может вонзикнуть желание использовать подзапросы или JOIN.
-- Конечно, JOIN по производительности предпочтительнее подзапросов,
-- а производительность конструкций JOIN и OVER окажется одинаковой.
-- Но OVER даёт больше свободы, чем жесткий JOIN.
-- Да и объем кода в итоге окажется гораздо меньше


-- Для начала

-- Оконные функции начинаются с оператора OVER и настраиваются с помощью трёх других операторов:
-- PARTITION BY, ORDER BY и ROWS.

-- Про ORDER BY, PARTITION BY и его вспомогательные операторы LAG, LEAD, RANK мы расскажем подробнее

-- Все примеры основаны на датасете олимпийских медалистов от Datacamp.
-- Таблица называется summer_medals и содержит результаты Олимпиад с 1896 по 2010:

-- ROW_NUMBER и ORDER BY

-- Как уже говорилось выше, оператор OVER создаёт оконную функцию.
-- Начнем с простой функции ROW_NUMBER, которая присваивает номер каждой выбранной записи:

SELECT
athlete,
event,
ROW_NUMBER() OVER() AS row_number
FROM Summer_Medals
ORDER BY row_numbers ASC;


-- PARTITION BY и LAG, LEAD и RANK

-- PARTITION BY позволяет сгруппировать строки по значению определенного столбца.
-- Это полезно, если данные логически делятся на какие-то категории
-- и нужно что-то сделать с данной строкой с учетом других строк той же группы
-- (скажем, сравнить теннисиста с остальными теннисистами,
-- но не с бегунами или пловцами).
-- Этот оператор работает только с оконными функциями типа LAG, LEAD, RANK и т.д.

-- LAG

-- Функция LAG берет строку и возвращает ту, которая шла перед не.
-- Например, мы хоти найти всех олимпийский чемпионов по теннису
-- (мужчин и женщин отдельно), начиная с 2004 года,
-- и для каждого из них выяснить, кто был предыдущим чемпионом.
-- Решение этой задачи требует нескольких шагов.
-- Сначала надо создать табличное выражение, которое сохранит результат запроса
-- "чемпионы по теннису с 2004 года" как временную именованную структуру для дальнейшего анализа.
-- А затем разделить их по полу и выбрать предыдущего чемпиона с помощью LAG:

-- Табличное выражение ищет теннисных чемпионов и выбирает нужные столбцы
WITH Tennis_Gold AS (
SELECT
Athlete,
Gender,
Year,
Country
FROM
Summer_Medals
WHERE
Year >= 2004 AND
Sport = 'Tennis' AND
event = 'Singles' AND
Medal = 'GOLD'
)
-- Оконная функция разделяет по полу и берёт чемпиона из предыдущей строки
SELECT
Athlete as Champion,
Gender,
Year,
LAG(Athlete) OVER (PARTITION BY gender
ORDER BY Year ASC) AS Last_Champion
FROM Tennis_Gold
ORDER BY Gender ASC, Year ASC;


-- LEAD

-- Функция LEAD похожа на LAG, но вместо предыдущей строки возвращает следующую.
-- Можно узнать, кто стал следующим чемпионом после того или иного спортсмена:

-- Табличное выражение ищет теннисных чемпионов и выбирает нужные столбцы
WITH Tennis_Gold AS (
SELECT
Athlete,
Gender,
Year,
Country
FROM
Summer_Medals
WHERE
Year >= 2004 AND
Sport = 'Tennis' AND
event = 'Singles' AND
Medal = 'Gold'
)
-- Оконная функция разделяет по полу и берёт чемпиона из следующей строки
SELECT
Athlete as Champion,
Gender,
Year,
LEAD(Athlete) OVER (PARTITION BY gender
ORDER BY Year ASC) AS Future_Champion
FROM Tennis_Gold
ORDER BY Gender ASC, Year ASC;


-- RANK

-- Оператор RANK похож на ROW_NUMBER, но присваивает одинаковые номера строкам с одинаковыми значениями,
-- а "лишние" номера пропускает.
-- Есть также DENSE_RANK, который не пропускает номеров. 
-- Звучит запутанно, так что проще показать на примере.
-- Вот ранжирование стра почислу олимпиад, в которых они участвовали, разными операторами:





